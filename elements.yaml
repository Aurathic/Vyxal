- modifier: "¡"
  name: Map Over Prefixes
  description: Map an element over the prefixes of an item.
  arity: 1
  elements: 1
  tests:
    - program: "⟨1|2|3|4|5|6⟩ ∑¡"
      output: [1, 3, 6, 10, 15, 21]
    - program: "`Hello, World!` L¡"
      output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

- modifier: "¿"
  name: Conditional Execution
  description: Execute an element if the top of the stack is truthy.
  arity: 1
  elements: 1
  tests:
    - program: "5 6 1 +¿"
      output: 11
    - program: "5 6 0 +¿"
      output: 6

- modifier: "¤"
  name: Last Element as a Function
  description: Pushes the last element as a lambda.
  arity: 0
  elements: 1
  # This needs to be a parser test

- modifier: "¢"
  name: Last Two Elements as a Function
  description: Pushes the last two elements as a lambda.
  arity: 0
  elements: 2
  # This needs to be a parser test
  
- modifier: "€"
  name: Last Three Elements as a Function
  description: Pushes the last three elements as a lambda.
  arity: 0
  elements: 3
  # This needs to be a parser test


- modifier: "§"
  name: Last Four Elements as a Function
  description: Pushes the last four elements as a lambda.
  arity: 0
  elements: 4
  # This needs to be a parser test
 
 
- modifier: "©"
  name: Filter By Element
  description: Keep all items that satisfy a condition.
  arity: 1
  elements: 1
  tests:
    - program: "⟨1|2|3|4|5|6|7⟩ 3<¢©"
      output: [1, 2]
    - program: "⟨1|2|3|4|5|6|7⟩ 2%0=§©"
      output: [2, 4, 6]
 
 
- modifier: "®"
  name: Reject by Element
  description: Discard all items that satisfy a condition.
  arity: 1
  elements: 1
  tests:
    - program: "⟨1|2|3|4|5|6|7⟩ 3<¢®"
      output: [3, 4, 5, 6, 7]
    - program: "⟨1|2|3|4|5|6|7⟩ 2%0=§®"
      output: [1, 3, 5, 7]


- syntax: "\n"
  name: Newline
  description: NOP
  arity: Not Applicable


- modifier: "æ"
  name: Apply to Each Stack Item
  description: Apply an element to every item on the stack
  arity: varies
  elements: 1
  tests:
    - program: "1 2 3 4 dæ W"
      output: [2, 4, 6, 8]
    - program: "5 1 7 2 4 2+¢æ W"
      output: [7, 3, 9, 4, 6]
  
  
- modifier: "ð"
  name: Outer Product / Table
  description: Take the cartesian product of an item with itself and reduce each pair by an element
  arity: 1
  elements: 1
  tests:
     - program: "⟨1|2|3⟩ ×ð"
       output: [1, 2, 2, 3, 4, 3, 6, 6, 9]

- syntax: "▲"
  name: Base Compressed String
  description: Open or close a bijective base 255 compressed string
  arity: 0

- syntax: "▼"
  name: Base Compressed Number
  description: Open or close a bijective base 255 compressed number
  arity: 0


- syntax: "⟨"
  name: List Open
  description: Open a list literal
  arity: 0
  tests:
    - program: "⟨1|2|3|4|5⟩"
      output: [1, 2, 3, 4, 5]
    - program: "⟨`abc`|`def`|`ghi`⟩"
      output: ["abc", "def", "ghi"]
    - program: "⟨⟨1|2|3⟩|4|`abc`⟩"
      output: [[1, 2, 3], 4, "abc"]

- syntax: "⟩"
  name: List Close
  description: Close a list literal
  arity: 0

- syntax: "λ"
  name: Lambda
  description: Open a lambda statement - an anonymous function that gets pushed to the stack
  arity: varies
  tests:
    - program: "3 6 λ2|+;"
      output: 9
    - program: "`abc` λ4*"
      output: "abcabcabc"
    
- syntax: "ƛ"
  name: Map Lambda
  description: Map a function over an item.
  arity: 1
  tests:
    - program: "10 ƛ1+;`
      output: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    - program: "`abcdef` ƛ2×;"
      output: ["aa", "bb", "cc", "dd", "ee", "ff"]
    - program: "1 11r ƛ4%0=;
      output: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]

- syntax: "Ω"
  name: Filter Lambda
  description: Keep items from a list where a predicate is truthy
  arity: 1
  tests:
    - program: "⟨ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 ⟩ Ω2%0=;"
      output: [2, 4, 6, 8, 10]
    - program: "`Big Shot` Ω`io`nc¬;"
      output: ["B", "g", "S", "h", "t"]
  
- element: "×"
  name: Multiplication / Ring Translate
  description: Multiply two numbers together / Repeat a string / Ring translate one string according to another
  arity: 2
  overloads:
    num-num: lhs * rhs
    num-str: rhs repeated lhs times
    str-num: lhs repeated rhs times
    str-str: ring translate rhs according to lhs
  vectorise: true
  tests:
    - inputs: [5, 20]
      output: 100
    - inputs: ["abc", 5]
      output: "abcabcabcabcabc"
    - inputs: [3, "abcde"]
      output: "abcdeabcdeabcde"
    - inputs: ["aeiou", "hello"]
      output: "alihu"
  
